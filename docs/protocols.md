# Delectus 2 Protocols

## Change protocol

Following are the change operations supported by the Delectus
engine.

| Name                        |
|-----------------------------|
| create-collection           |
| mark-collection-deleted     |
| destroy-collection          |
| add-list-to-collection      |
| remove-list-from collection |
| create-list                 |
| mark-list-deleted           |
| destroy-list                |
| add-column-to-list          |
| mark-column-deleted         |
| destroy-column              |
| add-row-to-list             |
| mark-row-deleted            |
| delete-row                  |
| update-field                |

The data storage engine executes these operations when the sync engine
or the user interface requests them. In either case, the operation
changes the state of the datastore, computes a new state token for it
(a hash of the store's new state), and appends the state token to the
state log. It also adds the executed command to the change
log. Operations that update values record both the value before the
operation and the value after, so that recorded change operations can
be undone and redone.

It's possible for a sync engine to enqueue two operations that make
conflicting changes to the same element of the datastore. For example,
an engine might receive two change messages, each of which updates the
same field of the same list to two different values. The sync engine
can tell that the two messages are in conflict because each one
references the same parent state.

In this case, the sync engine sorts the change messages
deterministically, using the same rules on all instances of the sync
engine. It then performs the changes in the resulting order. The
second and later change messages that are in conflict are updated so
that their reference states are the states generated by the
previously-applied change, so that a consistent sequence of changes is
recorded.

