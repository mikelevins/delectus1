# Delectus 2 Protocols

## Change protocol

Following are the change operations supported by the Delectus
engine.

| Name                          |
|-------------------------------|
| create-collection             |
| mark-collection-deleted       |
| destroy-collection            |
| add-object-to-collection      |
| remove-object-from collection |
| create-list                   |
| mark-list-deleted             |
| destroy-list                  |
| add-column-to-list            |
| mark-column-deleted           |
| destroy-column                |
| add-row-to-list               |
| mark-row-deleted              |
| destroy-row                   |
| update-field                  |

The data storage engine executes these operations when the sync engine
or the user interface requests them. The sync protocol operates on
**Delectus containers**, updating the state represented by their
contents.

When the engine executes a change-protocol operation, the operation
updates the state of the target container according to the operation's
specification, pushes a record of the operation (along with old and
new values for any updated values in the container) onto the
container's change log, then computes a new state token by hashing the
updated change log. It then appends the new state token to the
container's state log.

The entire update of the container is performed atomically, in a
transaction. If an error occurs during processing, the container's
state is left unchanged.

### Sync conflicts

It's possible for a sync engine to enqueue two operations that make
conflicting changes to the same element of the datastore. For example,
an engine might receive two change messages, each of which updates the
same field of the same list to two different values. The sync engine
can tell that the two messages are in conflict because each one
references the same parent state.

In this case, the sync engine sorts the change messages
deterministically, using the same rules on all instances of the sync
engine. It then performs the changes in the resulting order. The
second and later change messages that are in conflict are updated so
that their reference states are the states generated by the
previously-applied change, so that a consistent sequence of changes is
recorded.

