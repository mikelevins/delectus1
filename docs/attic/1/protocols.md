# Delectus 2 Protocols

## Change protocol

Following are the change operations supported by the Delectus
engine.

| Name                          |
|-------------------------------|
| update-field                  |
| add-row                       |
| mark-row-deleted              |
| add-column                    |
| rename-column                 |
| mark-column-deleted           |
| create-list                   |
| rename-list                   |
| mark-list-deleted             |
| update-list-notes             |
| create-collection             |
| rename-collection             |
| mark-collection-deleted       |
| update-collection-notes       |

The data storage engine executes these operations when the sync engine
or the user interface requests them. The sync protocol operates on
**Delectus containers**, updating the state represented by their
contents.

When the engine executes a change-protocol operation, the operation
updates the state of the target container according to the operation's
specification, pushes a record of the operation (along with old and
new values for any updated values in the container) onto the
container's change log, then computes a new state token by hashing the
updated change log. It then appends the new state token to the
container's state log.

The entire update of the container is performed atomically, in a
transaction. If an error occurs during processing, the container's
state is left unchanged.

> Note: In Delectus 2.0 there are no change operations that destroy
> stored data. For example, there is no destroy-row or
> destroy-list. Users may mark a list, collection, row, or column
> 'deleted' and client UIs will normally hide them, unless the user
> specifically asks to see deleted content.

> The reason that Delectus does not support destroying deleted content
> is that destroying content leads to troublesome semantics that can
> break the sync model. For example, suppose a user adds a list to a
> collection, then destroys it. The collection now has a reference to
> a nonexistent object, with no way to reconstruct it. The sync model
> requires Delectus to be able to reconstruct any state in the history
> of a list or collection, and so we do not actually destroy deleted
> data.

> We may add the ability in the future to destroy content. Most likely
> it will require rebuilding a change history from start to finish,
> with the destroyed content omitted, then marking the change history
> somehow to inform sync peers of the change.

### Sync conflicts

It's possible for a sync engine to enqueue two operations that make
conflicting changes to the same element of the datastore. For example,
an engine might receive two change messages, each of which updates the
same field of the same list to two different values. The sync engine
can tell that the two messages are in conflict because each one
references the same parent state.

In this case, the sync engine sorts the change messages
deterministically, using the same rules on all instances of the sync
engine. It then performs the changes in the resulting order. The
second and later change messages that are in conflict are updated so
that their reference states are the states generated by the
previously-applied change, so that a consistent sequence of changes is
recorded.

