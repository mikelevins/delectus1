# Delectus 2 Data Objects

## User objects

**User objects** are data objects that are visible to users of
Delectus. Delectus 2 manages a **User's** **Collections** of
**Lists**. A **User** is a representation of a person who interacts
with Delectus, and who owns some Lists and Collections. A **List**
consists of a sequence of **Rows** divided into labeled **Columns**,
with a **Field** for each column of each row.

**Collections**, **Lists**, **Rows**, **Columns**, and **Fields** are
**User Objects**.

## Platform objects

**Platform Objects** are not directly visible to Delectus users. They
are the building blocks that Delectus developers use to build the
application.

These objects include the **view**, **change**, and **sync
protocols**, which create, edit, and present stored objects for users,
the **data engine**, which implements the protocols on different
platforms, and **client applications**, which present the data objects
and protocols as understandable user interfaces.

Finally, an object called a **Curator** ties together all of these
parts on each supported platform. The Curator is the endpoint that
receives and processes protocol requests, and which organizes
nonvolatile storage to ensure that Collections and Lists persist and
can be reconciled.

## Identity

A User Object may be stored in more than one location. The **sync
engine** uses the **change protocol** to resolve differences that
arise in different copies of the same object.

In order for this reconciliation to work, Delectus requires a way to
identify which stored objects are copies of which other stored
objects. It solves this problem by assigning **identities** to Users,
Lists and Collections. An **identity** is signified by a
globally-unique identifier, represented in Delectus 2 by a v4 UUID. If
two objects have the same identifier, Delectus considers that they
have the same identity--in other words, they are two versions of the
same object.

It is an error to find that the same identity belongs to two objects
of different types.. In that case, both objects are invalid.

Delectus can determine whether two copies of the same object are
consistent by comparing **state tokens**. A **state token** is a
cryptographic hash (in Delectus 2, SHA3) of the contents of the
object's change log. Every List and every collection starts existence
empty, and acquires its contents by means of a sequence of change
operations. Apply the same sequence of change operations to two empty
lists or collections, and you wind up with two copies of the same
data. A hash of an object's change history therefore uniquely
identifies the state of the object.

>NOTE: This invariant requires that change messages are always
>deterministically reduced to a standard normal form before they are
>executed and stored. In order for change history to work, two
>instances of the same change message must generate the same hash,
>which means that both must be textually the same before they are
>hashed.

When Delectus detects that two objects with the same identity have
different change histories, it initiates a reconciliation. The steps
in a reconciliation are:

1. Compare the two change histories to find the common subset
2. Merge the subsets that differ into a single new sequence
3. When two change messages specify different changes to the same
preceding state, they are considered to be in conflict. Resolve the
conflict by deterministically sorting them into a predictable order
(one that will be the same on all implementations of the sync protocol
on all platforms)
4. Apply the merged sequence of change messages to both objects. When
applying a merged sequence that contains conflicts, the messages that
are in conflict will each reference the same preceding state. In that
case, rewrite the conflicting change messages so that the first of
them still references the same preceding state, but the later ones
reference the new state generated by applying the earlier one(s). In
other words, both (or all) conflicting changes are applied, but they
are ordered so as to produce the same result on both objects.

## Objects without identity

**Columns** and **Rows** lack identity in the sense of Lists and
Collections. They are assigned IDs that are guaranteed unique only
within a given List.

A **Field** is uniquely identified within a List by its row and
column. Its value is uniquely determined by the sequence of change
messages that have been applied to the objects that contain it.

## Object types

### Field values

Field values are the primitive, atomic value objects stored by a
Delectus container. They include the following types:

- **null:** The absence of any value
- **Boolean:** True or false
- **Number:** A numeric value
- **Text:** A text string
- **DateTime:** A date and time
- **Link:** A URI reference to some resource. 
- **Reference:** A reference to a locally-known List or Collection

### Rows

A **Delectus row** consists of a sequence of field values. Rows do not
occur bare; they exist only as members of **Delectus lists**.

#### Deletion

Rows may be marked **deleted**. A deleted Row is not normally
displayed in a user interface, though a user can specifically request
to see all deleted items.

### Columns

A **Delectus column** consists of a sequence of text values. Columns
do not occur bare; they exist only as attributes of **Delectus
lists**. Each Column in a List has one of the following types:

- Boolean
- Number
- Text
- DateTime
- Link
- Reference

#### Deletion

Columns may be marked **deleted**. A deleted Columns is not normally
displayed in a user interface, though a user can specifically request
to see all deleted items.

### Lists

A **Delectus list** consists of a sequence of **Delectus rows**,
together with a sequence of **Delectus columns**. In a given list, the
number of fields in each row must be equal to that of all the others,
and equal to the number of columns.

Each Column label must be unique in the List. It is an error to
attempt to create a Column with a label that is already in use by
another Column.

### Collections

A **Delectus collection** contains zero or more Lists and
Collections. A List may appear on a given Collection exactly
once. Each List and each Collection belongs to either zero or one
Collection. Users may remove Lists and Collections from a Collection,
and may add them to a Collection.

