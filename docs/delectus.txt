Delectus architecture and design

I. Introduction

The name "delectus" is taken from the Latin "delectum", for something
consciously chosen. A delectus is a sequence of tuples.

Delectus is a family of applications designed for storing, viewing,
and editing delecti. Most simply, it's an application for managing
lists of things, or, rather, lists of lists of things.

The delectus concept is language-independent; it is intended to
provide a nonvolatile representation of persistent data useful in a
variety of applications. Delectus defines the operations and logical
structure of a delectus, and also defines a language- and
platform-independent representation for delectus data, so that
applications that use it can be conveniently developed for a variety
of platforms without concerning themselves about format conversions.

II. An Example

Here's an example delectus:

  [("index", "Title",                      "Author")
   (1,       "War of the Worlds",          "H.G. Wells")
   (2,       "Foundation and Empire",      "Isaac Asimov")
   (3,       "Stranger in a Strange Land", "Robert Heinlein")]

The definition of a delectus requires that each tuple have the same
number of elements. By convention, the first tuple (tuple zero) is
called the "key sequence", and is treated specially: only strings are
allowed as elements of the key sequence, and the first element
(element zero) is always the string "index". The other elements may be
any string values, but no string may appear more than once. Elements
of the key sequence are compared in a case-insensitive manner, so that
"bob" and "Bob" are considered the same. It would therefore be an
error to specify a delectus with a key "bob" and also a key "Bob".

The astute observer might notice that, if every delectus has the
"index" column, and if its contents are always the key "index"
followed by the natural numbers, the one could omit the index column
from a delectus representation and simply treat it as if it's always
there. That would certainly be a viable strategy for implementing
delectus representations.

III. Values

The values that appear as the elements of each tuple in a delectus may
be of the following types:

  Null
  Boolean
  Integer
  Float
  Bytevector
  Sequence
  Map

These types were chosen consciously to provide a rich enough set of
basic data types to represent most any kind of data conveniently,
while also being easy to implement in many different common
programming languages on many different platforms. The set of types
allowed is intentionally similar to those allowed in JSON and
MessagePack serialization formats.

The Null value has two special meanings:

  1. Used as an element of a tuple, it repreents the absence of a
     value. If you interpret a delectus as a map, or as a sequence of
     maps (see the next section), then a Null value indicates that the
     key represented by the column is not present in the map.

  2. Used as a delectus, Null represents the empty delectus, a
     delectus with no elements. Any empty sequence [] is also
     considered equivalent to Null in this role. The empty sequence is
     still considered to have one column: the "index" column, and one
     row, row zero (the row that contains the key sequence). 

IV. Interpretations

A delectus is an extremely flexible means of organizing data. It's
rich enough to represent sequences or key/value maps in several
different ways:

  - a delectus with only two keys, "index" and one other, is a
    convenient representation of a named list or other ordered
    sequence.

  - a delectus with three keys--two besides "index"--makes a
    convenient representation of a map from keys to values.

  - a delectus with M keys and N tuples makes a convenient
    representation of a sequence of N map objects, where the maps all
    share the same set of keys.

  - a delectus can conveniently be interpreted as a set of rows and
    columns, like those in a relational database, and can be indexed
    and otherwise manipulated in much the same way. Each tuple is a
    row; each position in a tuple is a column. It's often convenient
    to speak of a delectus as rows and columns, rather than as a
    sequence of tuples.

V. APIs

There are three Delectus APIs: the Data API, the Presentation API, and
the Storage API.

The Data API concerns itself with creating and copying delecti, adding
and removing rows and columns, and fetching and updating values stored
in them.

The Presentation API concerns itself with manipulating views of
delecti: with sorting and filtering them. The Presentation API also
provides operations for marking or columns deleted, but it's the Data
API that actually performs deletions. 

We separate marking deletions from actually carrying them out both
because it makes deletion operations safer and more efficient, and
because it's convenient for users to be able to put rows and columns
"in the trash" without actually losing the data. Separating marking
from execution is analogous to the distinction between putting
something in the trash, and emptying the trash.

The Storage API handles writing delectus data to nonvolatile storage
and reading it back again, and, more generally, with serialization and
deserialization of delectus data.

The protocols are described in pseudocode that is designed to provie
enough information to guide implementation in any common programming language.

  A. The Data API

   make-delectus :: () => Delectus
   make-delectus :: ([label :: String]) => Delectus
   make-delectus :: ([label :: String], [tuple :: [Value]]) => Delectus

     Returns a newly-constructed delectus. If no arguments are
     supplied, the new delectus is the empty delectus, or Null.

     If a list of strings is supplied, then they become the key
     strings in the key sequence, but no additional tuples are
     included in the new delectus.
     
     If both a list of strings and a list of tuples is supplied, then
     the key sequence of the new delectus has the input strings as
     keys (plus, of course, the "index" key), and has tuples as given
     in the list of tuples. All values in the tuples must be valid
     delectus values, and all tuples must be the same length as the
     key sequence.



  B. The Presentation API

  C. The Storage API

VI. Serialization Format

Delectus specifies the byte-level serialization format for delectus
data in order to make it possible to implement fast binary
serialization of delectus data that works identically across languages
and platforms, using the same format. The objective is that any
implementation of the Delectus protocols should work identically on a
given delectus file, regardless of what implementation wrote it.
