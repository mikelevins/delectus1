= Delectus 2 Data
:toc:

== Concepts

=== Lists

Conceptually, Delectus manages documents called *lists*. A *list* is a named sequence of *items*. An *item* is a sequence of *fields* containing *values*.

A Delectus list is a table: each item is a row, and each field of the row belongs to a named *column*. All items have the same columns with the same names and other attributes, but the values in the fields are unique to each item.

A Delectus list starts out empty. A user builds its contents piece-by-piece, by performing *edit operations*: adding items and columns and updating fields and column attributes. Each edit changes the current state of the list.

There are four types of edits. Each one is represented by a named structure called an *op*. The four ops are:

. `*listname:*` Sets the name of the list.
. `*comment:*` Sets the list's comment text.
. `*columns:*` Sets the list's columns and their attributes.
. `*item:*` Adds or updates a single item.

At any given time, the state of a list is defined by the sequence of edits that has been performed on it. That sequence of edits is represented by a log of ops in *causal order*. Given that log, Delectus can always reproduce the state of the list at any point in its history. In fact, to Delectus, the op log _is_ the list.

*Causal order* means that a new op is always inserted after all existing ops, and no future edit or merge can cause the op to be moved before its predecessors. Preserving causal order is what enables Delectus to reconstruct the state of the list from the log of ops.

== Op syntax

Each op is an assertion of a change in a list's data. Before the op is inserted the list contains one set of data; afterward, it contains another. The op declares the state that changes and supplies the new  data.

Following is the abstract syntax of all four ops.

=== listname
===== Syntax: `listname  _revision_ _origin_ _timestamp_ _nameText_`

The `listname` op sets the name of the list to a user-specified string.

[cols="1,1,5",options="header"]
.`listname` Parameters
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus *node* that created it.
| `_nameText_` | `string` | The list's new name.
|===

=== comment
=====  Syntax: `comment _revision_ _origin_ _timestamp_ _commentText_`

The `comment` op sets the list's comment text to a user-specified string.

[cols="1,1,5",options="header"]
.`comment` Parameters
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus *node* that created it.
| `_commentText_` | `string` | The list's new comment text.
|===


=== columns
===== Syntax: `columns _revision_ _origin_ _timestamp_ {_label_: _attributes_}+`

The `columns` op sets the current state of the list's columns. The parameters given as `{_label_: _attributes_}+` are one or more objects that each specify the attributes of a column. The label identifies the column; the `attributes` object defines the column's attributes. Each label may appear only once in the argument list.

[cols="1,1,3",options="header"]
.`columns` Parameters
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus *node* that created it.
| `{_label_: _attributes_}+` | `object` | One object for each column. The key is the column's label; the value is an `attributes` object specifying the values of the column's attributes.
|===

===== The `attributes` object

In a `columns` op, the `attributes` object gives the values of a column's attributes. Column attributes are as follows:

[cols="1,2,6",options="header"]
|===
| attribute | type | description
| `id` | `identity` | The column's unique identity. The column's label is derived from this value by serializing it to a string and prepending the letter 'L'.
| `name` | `string` | The name given to the column by the user.
| `order` | `real` | The recommended presentation order of the column.
| `sort` | `null`, `'ASC'`, `'DESC'` | Whether to sort the list on this column, and in which direction.
| `title` | `Boolean` | Whether this is the list's *title column*.
| `subtitle` | `Boolean` | Whether this is the list's *subtitle column*.
| `deleted` | `Boolean` | Whether this column has been marked deleted.
|===

==== Attributes and presentation

The values of a column's attributes control how Delectus presents the column in its user interface.

* `*name*` gives the text Delectus uses to label the column in the UI.
* `*order*` tells Delectus the left-to-right order in which to present the columns.
* `*sort*` identifies which column to use for sorting the list's items, and whether to sort ascending or descending. At most one column may be designated as the sort column. If no sort column is designated then Delectus presents the items in timestamp order, newest last.
* `*title*` identifies the list's *title column*. In some views, the *title column* supplies text to be sued as the title of the item. At most one column may be designated the title column. If no title column is designated then Delectus arbitrarily uses the column with the lowest sort order as the title.
* `*subtitle*` identifies the *subtitle column*. In some views, the *subtitle column* supplies text to be sued as the subtitle of the item. If no subtitle column is designated then Delectus presents the items without a subtitle.
* `*deleted*` declares whether the user has marked the column deleted. Delectus does not present deleted columns or items unless the user specifically asks it to.

=== item
===== Syntax: `item _revision_ _origin_ _timestamp_ _itemid_ {_label_: _value_}+`

The `item` op sets the current state of a specified item. The coordinates `(origin, itemid)` uniquely identify the item. If it's an existing item then the op is an update to that item. If not, it's a new item.

The parameters given as `{_label_: _value_}+` are one or more objects that specify the values of the item's fields. The `_label_` identifies a column; the `_value_` gives the data for that column. Each label may appear only once in the argument list.

[cols="1,1,3",options="header"]
.`item` Parameters
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus *node* that created it.
| `_itemid_` | `identity` | The identity of the item.
| `_deleted_` | `Boolean` | Whether the item is marked deleted.
| `{_label_: _value_}+` | `object` | One object for each column. The key is the column's label; the value is the value in that column. The value may be `null`, a `Boolean`, a `number`, or a `string`.
|===

=== Identities

Delectus must be able to uniquely identify each item in a list and each edit that changes data. It's not sufficient to assign identifiers that are unique within a file, because Delectus supports editing different copies of a list and then merging the edits. If identifiers are only locally unique then they may collide with identifiers created in a different copy of the list. Identifiers must therefore be globally unique.

To satisfy these requirements, Delectus uses *identities*. An *identity* is a unique 16-byte value--a v4 UUID in binary form. Delectus uses them to identify Delectus *nodes* and to label user-created columns.

Identities appear in three different forms:

* *bytestring:* An identity value in raw, binary form. This is what we normally mean by the word "identity". +
For example: `#(91 219 70 247 242 21 67 205 168 61 23 181 3 110 7 247)`
* *identity string:* An identity serialized to a hexadecimal text string. +
For example: `"5bdb46f7f21543cda83d17b5036e07f7"`
* *column label:* An identity string with the letter 'L' prepended. +
For example: `"L5bdb46f7f21543cda83d17b5036e07f7"` +
Called a "column label" because Delectus uses these strings to label user-created columns in SQLite files.

All three forms are equivalent. A given identity represents the same 16 bytes, and stands for the same Delectus object, regardless of whether it appears as a bytestring, and identity string, or a column label. The above examples all refer to the same identity.

=== Nodes

A Delectus *node* is a specific install of the application running on a specific device in a specific user account. Delectus assigns an identity to each node and uses it to compute the unique identifications of ops and items.

The first time Delectus runs it generates a node identity and stores it in the user's filesystem. Every time it runs thereafter, it reads the identity from the file. If the file is corrupted or removed, Delectus generates a new one.

Replacing a node identity doesn't affect the correctness of Delectus data. It simply identifies the user's copy of Delectus as a new node; all new ops inserted in a file use the new node identity.

=== Origins

An *origin* is a 16-byte value computed by hashing a node identity with the Delectus process ID and the pathname of a list file. Delectus 2 uses the SHAKE128 hash for this purpose.

Each time Delectus opens a list file, it computes an origin for it. Each time it writes an op into the file, it tags the op with the origin. If the file is moved or copied then Delectus will compute a new origin and use it in any new ops. If the file is edited by a different user or a different process, or if it's edited on a different device, the origin will be different. These properties of the origin enable Delectus to distinguish different ops and identities from each other, even when they were created concurrently by different processes or different devices.

It's not possible to reverse the hash and recover the data that went into creating it, but Delectus doesn't need to. It only needs to guarantee that different processes, pathnames, and devices produce different origin values so that it can distinguish edits that come from different sources, and ensure that `(origin, identity)` and `(origin, revision)` pairs are globally unique.

=== Revisions

Each op is marked with a *revision*. A *revision* is an integer attached to the op at the time it's created. Each time Delectus inserts an op, it increments the list file's revision counter and inserts the new value with the op.

Each list file has its own revision counter. Because revision counters are updated independently and concurrently across devices and files, Delectus can't preserve the uniqueness of revisions across copies of a list, but even though revisions are not globally unique, the combination of an origin and a revision is. Each op can therefore be uniquely identified by the coordinates `(_origin_,_revision_)`.

Although it's inevitable that the revision numbers from a remote copy of a list will duplicate local ones, and although we can still distinguish edits with the same revision as long as they have different origins, it's still useful to minimize duplication. For one thing, once a list has merged edits from another copy, we would prefer not to insert more ops locally with duplicate revisions. It's better for ordering ops if all newly-added ops have new revision numbers.

Therefore, any time we merge ops from a different copy of a list, we determine the highest revision number we've seen in any op--local or global--and reset the revision count to one greater than that.

=== Itemids

Besides uniquely identifying ops, Delectus also needs to uniquely identify items. A user may update the same item many times, which means inserting many ops that all represent versions of the same item. Origin and revision are enough to identify an op, but not enough by themselves to distinguish one item from another. Origin and revision tell us which op we're talking about, but if it's an `item` op, how do we know whether it's adding a new item or updating an old one?

To solve that problem, we use an additional coordinate: `itemid`. The `itemid` is an integer that uniquely identifies a specific item with respect to a given origin. Like a revision, an itemid is not unique in itself, but the combination of the itemid with an origin is.

To recap, the unique identifying coordinates that Delectus uses are:

* For identifying an *op:* `(_origin_, _revision_)`
* For identifying an *item:* `(_origin_, _itemid_)`
* For identifying *a specific update of a specific item:* `(_origin_, _revision_, _itemid_)`

=== Timestamps

Each op carries a `timestamp`, which is an integer count of the number of milliseconds since midnight, January 1, 1900 GMT. The upper bound of a Delectus 2 timestamp is given by the range of integers that SQLite can represent. The largest integers SQLite can store are 64-bit signed, so timestamps have 63 bits of precision. That means the maximum timestamp is 9,223,372,036,854,775,807, which corresponds to  August 17th, 292,278,924 AD, at 12:55 PM.

Delectus assigns a timestamp to each op, but it doesn't use the timestamps to determine the current state of the list file's data. It accomplishes that using only the op and item coordinates discussed previously.

It uses timestamps to make the presentation of list data congenial for users. For example, Delectus determines which ops represent the current state of all the list's items using itemids, revisions, and origins, but once it has the correct `item` ops, the default view uses timestamps to present them in approximately the order that they were created.

== SQLite tables

A Delectus list file is a SQL database; Delectus stores ops and supporting data in a set of SQLite tables. This section describes those tables and how Delectus uses them.

=== Op tables

Each op type is stored in its own table.

==== The `listnames` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `name` | `TEXT` |
|===

==== The `comments` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `comment` | `TEXT` |
|===

==== The `columns` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `_[label]_+` | `_[attributes]_+` |
|===

==== The `items` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `itemid` | `INTEGER` |
| `deleted` | `INTEGER` |
| `_[label]_+` | `_[value]_+` |
|===

=== The `latest_items` table

When Delectus opens a list file it executes a query that fetches the latest versions of all items in the `items` table. It stores the result in a temporary `latest_items` table. It then uses the `latest_items` table for all searches and other read operations on the list's items, enabling it to produce results more quickly than if it operated on the full `items` table.

When a user edits an item or column, Delectus inserts the resulting op into the persistent `items` table and then recomputes the `latest_items` table.

The structure of the `latest_items` table is identical to that of the `items` table.

=== The `delectus` table
=== Origin and identity maps
==== The `identities` table
==== The `origins` table
