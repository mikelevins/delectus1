= Delectus 2 Tables
:toc:

== Ops and the op log

Conceptually, a Delectus list is a named sequence of *items*, each of which contains user-created data in one or more named *columns*. All of the items of a given list have the same columns. Each item stores a value in each column. The values in different columns may be the same or different, and the values in the same column but different items may be the same or different.

Concretely, Delectus stores these objects in the form of rows in a set of tables in a SQLite file. Each row represents an *op*; an *op*--short for "operation"--is a tuple that asserts a change in the state of the list. A Delectus list file is an append-only, time-ordered log of ops. The current state of its data is the combination of the latest values in its ops.

There are three types of op:

. `listname` ops define or update the user-assigned name of the list.
. `columns` ops define or update the *userdata* columns of the list.
. `item` ops insert, update, or delete an individual item in the list.

NOTE: A fourth type of op, `sync`, is intended to record successful synchronization events, in which two or more list files are reconciled so that they contain the same data. The `sync` op is not yet defined because the details of the synchronization algorithm are not yet worked out.

A Delectus file contains one SQLite table for each of these op types. See the <<delectus-table-definitions>> section for a detailed description of each.

== Userdata and metadata

A Delectus list contains two types of data:

. *userdata* is data created and managed by the user.
. *metadata* is data created and managed automatically by Delectus to support application features.

As an example, when you add "milk" to a shopping list in Delectus, the text "milk" is *userdata*; the timestamp that records when you added the item to the list is *metadata*.

Delectus distinguishes the two types of data and stores them in distinct SQLite columns.

The set of metadata columns is predefined, and so are the labels of those columns.

The set of userdata columns, on the other hand, is open-ended, because a user may add a new column at any time.

== Identities [[identity-definition, identity]]

An `*identity*` is a v4 UUID represented as a 128-bit integer. Delectus uses identities to uniquely identify Delectus processes and userdata columns. It stores them as hexadecimal strings in the `delectus` table, and uses them to compute <<origin-definition>>s and <<userdata-column-label-definition>>s.

Each time Delectus runs, it generates an `identity`. It stores it in the variable `delectus:*process-identity*`. It then uses `delectus:*process-identity*` as an input to all subsequent <<origin-definition>> and <<userdata-column-label-definition>> computations.

== Origins [[origin-definition, origin]]

An `*origin*` is a 128-bit integer--a SHAKE128 digest--used to distinguish among the sources of edits in a Delectus file. It's computed from the current value of `delectus:*process-identity*` and the absolute pathname of a list file. Each time the Delectus process inserts an op into one of the file's tables, it writes the `origin` into the `origin` field of the op.

Each combination of a Delectus process and a Delectus file yields a distinct origin. This property ensures that multiple processes updating multiple copies of the same Delectus list can always merge all of the changes into a single consistent state without collisions or data loss. All edits are distinguishable by a combination of `origin` and the *revision number* of the edit.

When a Delectus process closes a file or exits, it discards the `origin` associated with the file. It thereafter exists only as strings in the `origin` fields of certain ops in the file.

Delectus stores origins as `BLOB` values in the `origin` column of each SQLite table. It indexes rows of the tables on the `origin` column, and uses `origin` values in computing the current state of the Delectus list in the file.

NOTE: Storing origins in this way represents a dependence on implementation details of SQLite. SQLite can index BLOB values, but that feature is an extension to the SQL standard and is not generally supported by other databases. If at some point Delectus needs to support storage in other databases then we may have to invent a method of converting origins to a more suitable format for the destination database.

== Revision and item numbers

Delectus keeps a count, called the *revision number*, of the number of times each list file has been updated. It stores this count in the `next_revision` field of the `delectus` table. Each time it inserts an op to any of the tables, it stores the current value of `next_revision` in the op's `revision` field and increments `next_revision`.

Delectus also keeps a count of how many new items it has added to each list file. It stores this count in the `next_item` field of the `delectus` table. When it inserts an `item` op that is not an update to an existing op, it stores the current value of `next_item` in the `item` field of the op, and increments `next_item`. When Delectus inserts an update to an existing item, it doesn't allocate a new item number. Instead, it reuses the item number of the previous op, thud identifying the new op as an update to the old item.

This is how Delectus is able to identify all the ops that have updated a given item, and how it distinguishes between a new item and an update to an old one.

== Userdata column labels [[userdata-column-label-definition, userdata column label]]

A *userdata column label* is an <<identity-definition>> string, but with the letter "I" prepended. Delectus uses these strings as the labels of userdata columns.

Why not simply use the names that users give to their columns?

Because a user might edit the same list on two or more devices, and might give the same name to two or more columns with different contents. If we had to rely on user-assigned names for columns, then when a user gave the same name to two different columns, we'd have a conflict between them as soon as we tried to merge the two versions of the file. By instead using autogenerated `identity` strings as labels, we ensure that we can always safely merge the user's edits. Even if the user gives the same name to two columns created on different devices, Delectus knows that they're different and can preserve both.

Delectus prepends the letter "I" to `identity` strings when it uses them as column labels. This practice is to make it easier to work with SQLite. SQlite has some restrictions on the names of columns that you can use without jumping through extra hoops. In order to avoid those complications, we simply stick an "I" onto the front of the `identity` when we want to use it as a column label.

Users normally never see `identity`-based column labels. When presenting a userdata column in the user interface, Delectus instead displays the name that the user gives to the column.

== Uniquely identifying ops and items

Because you can edit two or more copies of a list on different devices or in different processes, it's possible--common, in fact--for Delectus to assign the same revision or item number to different ops. Neither the revision number nor the item number are globally unique.

On the other hand, if Delectus is concurrently editing two or more copies of a list, whether on different devices or in different processes on the same device, then each Delectus process has a different `origin`. Delectus computes a new, unique `origin` each time a Delectus process opens a list file.

This means that, although a revision number is not globally unique, the pair `(revision, origin)` _is_ globally unique. In the same way, the pair `(item, origin)` is unique for any given item and origin.

Delectus can therefore uniquely identify any op using the pair `(revision, origin)`, and can uniquely identify any item using `(item, origin)`.

== Timestamps

Each time Delectus writes an op, it assigns it a *timestamp*. The timestamp is a count of the number of seconds since 1900-01-01T00:00:00Z--that is, since the UTC epoch. These timestamps exist to help users  know when they last edited an item in a list.

NOTE: SQLite INTEGER values are 64-bit signed integers, meaning they offer 63 bits of precision (plus a sign bit). The Delectus timestamp will therefore roll over at 292277026526-12-05T15:30:07.000000Z--that is, on December 5th of the year 292,277,026,526 A.D., at 3:30 PM.

=== The current state

The current state of the data in a Delectus list is just the composition of all the newest relevant ops. For `listname` and `columns` ops, this simply means the ops with the highest revision numbers. If two or more ops of the same type have the same revision number, then Delectus sorts them by origin and chooses the one that ends up last as the current value.

For `item` ops, the process is similar,  but we have to account for the fact that there can be multiple versions of the same item. To determine the current state of all items, Delectus partitions the `item` ops into groups by their `item` and `origin` fields. Next, it sorts each group of items by the `revision` and `origin` fields. Finally, it collects the last element of each group, yielding the latest version of each item.

Delectus never discards the older version of any item. It's always possible to ask it to show you the version history of any item, so that, if its merge algorithm yields a final value different from the one you wanted, you can select an older one and make it current.

The same goes for `columns` and `listname` ops: the history of each type of op is stored in the list file, and you can easily browse and restore old values as-needed.

== SQlite Tables [[delectus-table-definitions, Delectus tables]]

=== 'delectus'

Records the `identity` of the list, along with some other supporting data.

[cols="1,2,4",options="header"]
.Structure of the `delectus` table
|===
| column | type | description
| `listid` | `TEXT`  | The unique `identity` of this list, assigned when it was created.
| `parent` | `TEXT`  | The  `listid` of the Delectus list from which this one was derived by a *compaction*. If `NULL`, it signifies that the list is not a child of another list, but was created independently.
| `format` | `TEXT`  | The version of the Delectus file format in this list file
| `next_revision` | `integer`  | The revision number that will be assigned to the next op created in this file.
| `next_item` | `integer`  | The item number that will be assigned to the next item created in this file.
|===

=== 'listnames'

The `'listnames'` table records `listname` ops, which set the name of the list. The current name of the list is the value of the `name` field of the latest row of the `listnames` table.

[cols="1,2,4",options="header"]
.Structure of the `listnames` table
|===
| field | type | description
| `origin` | `BLOB` | The `identity` of the Delectus process that created this op.
| `revision` | `INTEGER` | The revision number of this op.
| `timestamp` | `INTEGER` | The time that the op was created, as reported by the creating node.
| `name` | `TEXT` | The new name of the list.
|===

=== 'columns'

The `'columns'` table records `'columns'` ops, which specify the identities and attributes of *userdata* columns.

[cols="1,2,4",options="header"]
.Structure of the `'columns'` table
|===
| field | type | description
| `origin` | `BLOB` | The `identity` of the Delectus process that created this op.
| `revision` | `INTEGER` | The revision number of this op.
| `timestamp` | `INTEGER` | The time that the op was created, as reported by the creating node.
| `_[label]_+` | `identity` | A `column` object defining the attributes of the column.
|===

The notation `_[label]_+` represents one or more column labels, each of which is an `identity` string. There may be any number of columns, each created by the user, and each with its own _label_. The contents of each column in the `'columns'` table is a JSON object that gives the attributes of the column.

The `'columns'` and `'item'` tables are required to have the same `_[label]_+` columns.

=== 'items'

[cols="1,2,4",options="header"]
.Structure of the `'items'` table
|===
| field | type | description
| `origin` | `BLOB` | The `identity` of the Delectus process that created this op.
| `revision` | `INTEGER` | The revision number of this op.
| `timestamp` | `INTEGER` | The time that the op was created, as reported by the creating node.
| `item` | `INTEGER` | An `itemid that uniquely identifies the item that this op represents.
| `deleted` | `Boolean` | Whether this item is marked deleted.
| `_[label]_+` | JSON `null`, `Boolean`, `number`, or `string` | A JSON value.
|===

The notation `_[label]_+` represents one or more column labels, each of which is an `identity` string with the letter "I" prepended. There may be any number of columns, each created by the user, and each with its own _label_. The contents of each column in the `'items'` table is a JSON object that gives the value of that column in the item.

The `'columns'` and `'item'` tables are required to have the same `_[label]_+` columns.
