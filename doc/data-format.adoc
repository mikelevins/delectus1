= Delectus 2 Data
:toc:

== Concepts

Conceptually, Delectus manages documents called *lists*. A *list* is a named sequence of *items*, each of which is a sequence of *fields* containing *values*.

A Delectus list is a table: each item is a row of the table, and each field belongs to a named *column*. All items have the same columns with the same name and other attributes, but the values in the fields are unique to each item.

A Delectus list starts out empty. A user builds its contents piece-by-piece, by performing *edit* operations. Each edit changes the current state of the list.

There are four types of edits. Each one is represented by a named operation called an *op*. The four ops are:

. `*listname:*` Sets the name of the list.
. `*comment:*` Sets the list's comment text.
. `*columns:*` Sets the list's columns and their attributes.
. `*item:*` Adds or updates a single item.

At any point in time, the state of a list is defined by the sequence of edits that has been performed on it. That sequence of edits is represented by a log of ops in *causal order*. Given that log, Delectus can always reproduce the state of the list at any point in its history. In fact, to Delectus, the op log _is_ the list.

== Op syntax

Each op is an assertion of some change in the state of a list's data. Before the op is inserted into the log, the list contains one set of data; afterward, it contains another. The op declares the state that changes, including all of the new data.

Besides the new state of the data, each op also takes a _metadata_ parameter that carries certain additional information Delectus requires in order to support application features and maintain the consistency of list data. We'll discuss this metadata in the next section.

==== `listname _metadata_ _nameText_`

[cols="1,2,4",options="header"]
|===
| parameter | type | description
| `_metadata_` | `metadata` | See the section "Op metadata"
| `_nameText_` | `string` | The list's new name.
|===

The `listname` op sets the name of the list to a user-specified string.

==== `comment _metadata_ _commentText_`

[cols="1,2,4",options="header"]
|===
| parameter | type | description
| `_metadata_` | `metadata` | See the section "Op metadata"
| `_commentText_` | `string` | The list's new comment text.
|===

The `comment` op sets the list's comment text to a user-specified string.

==== `columns _metadata_ _columnsState_`

[cols="1,2,4",options="header"]
|===
| parameter | type | description
| `_metadata_` | `metadata` | See the section "Op metadata"
| `_columnsState_` | `columnsState` | The current columns of the list and their attributes.
|===

The `columns` op sets the current state of the list's columns. The `_columnsState_` parameter is an object that maps `_columnLabel_` keys to `_columnAttributes_` values. Each key is the unique ID of a column in a form that SQLite can use as a column label; each value is an object that defines the new state of the column's attributes.

==== `item _metadata_ _itemState_`

[cols="1,2,4",options="header"]
|===
| parameter | type | description
| `_metadata_` | `metadata` | See the section "Op metadata"
| `_itemState_` | `itemState` | The new state of the item data.
|===

== Op metadata

Besides the new state of a list's data, each op has to carry some additional information that Delectus uses for processing and storing the ops. For example, Delectus must be able to impose a predictable order on all of the ops in the log, even when they've been assembled from different copies of the list edited on different devices.

Device A may insert one new op after the existing op _N_, and device B might insert another. Once the different copies of the list are merged, they can't both be the op that follows _N_; one or the other must be inserted later. Moreover, we must ensure that the resulting order is the same in all copies of the list. Delectus stores metadata in each op that it can use to make those decisions in a reliable way, so that all copies of the list end up the same.

All ops carry a common set of metadata, defined as follows:

[subs=+quotes]
----
{
  origin: _origin_,
  revision: _revisionNumber_,
  parent_origin: _origin_,
  parent_revision: _revisionNumber_,
  timestamp: _delectusTimeStamp_
}
----

`item` ops additionally carry an `itemid` field:

[subs=+quotes]
----
{
  itemid: _identity_,
}
----

=== `revision`

Each op is marked with a *revision*, which is an integer count of the changes made in the current file. Each time the revision count is assigned to an op, it's increased by one.

Delectus supports editing multiple copies of a list on different devices and then merging the edits together. When you edit a list on two or more devices, some different edits may get the same revision number. That works out okay, as long as we can keep the edits straight--as long as we don't confuse one for another--and as long as, overall, the revisions number all increase with each edit.

The next section describes how we distinguish edits that come from different places. We keep revision counts consistent by always adjusting a file's revision count to be one greater than the greatest one we've seen in the file so far. Thus, if we merge in edits from another file, and their largest revision count is larger than ours, we reset ours to be one greater than their greatest. That way we never insert a new op with a revision that is less than the greatest one we've seen.

=== `identity` and `origin`

Delectus metadata must uniquely identify each item in a list, and each edit that changes the data. It's not sufficient to assign identifiers that are unique within a file, because Delectus supports editing different copies of a list and then merging the edits. The IDs of ops and items must therefore be globally unique.

An *identity* is a randomly-generated 16-byte value--a v4 UUID. Delectus uses them to identify a specific user's installation of Delectus on a given device (called the Delectus *node*), and to label user-created columns.

An *origin* is a 16-byte value computed by hashing a node identity with the pathname of a list file.

(We can store these identifiers more compactly by mapping them locally to integers. This optimization saves considerable space, but adds some complexity. Our mapping is purely local; we cannot know what identifiers remote copies may have seen. That means that when we merge ops from a remote copy, we have to remap the identifiers to incorporate any new ones from the merge data. When we remap them, we must then also change all references to them in the local file to use the new integers instead of the old ones. Finally, when serializing the op log for sync, we must resolve all integer references to the actual identifiers, since the remote copy's mapping may be different from ours.)

Each time Delectus opens a list file, it computes an origin for the file. Each time it writes an op into the file, it tags the op with the origin. If the file is moved or copied, then the origin changes. If it's edited by a different user or on a different device, the origin changes.

Each op is also marked with a *revision*. Although revisions are not globally unique, the combination of origin and revision is. Each op can therefore be uniquely identified by the coordinates `(_origin_,_revision_)`.

Besides uniquely identifying ops, Delectus also needs to uniquely identify items. A user may update the same item many times, which means inserting many ops that all represent versions of the same item. That means that origin and revision are not enough by themselves to distinguish one item from another. Origin and revision tell us which specific op we're talking about, but if it's an `item` op, how do we know whether it's adding a new item or updating an old one?

The answer is that we use an additional coordinate: `itemid`. The `itemid` is an integer that uniquely identifies a specific item with respect to a given origin. Like a revision, an itemid is not unique in itself, but the combination of the itemid with an origin is.

To recap, the unique identifying coordinates that Delectus uses are:

* *op:* `(_origin_, _revision_)`
* *item:* `(_origin_, _itemid_)`
* *a specific update of a specific item:* `(_origin_, _revision_, _itemid_)`

=== Order of edits

Revision numbers give Delectus a reliable way to sort ops into a stable order, even when the ops were created on different devices. Unfortunately, it's possible for concurrent edits (that is, edits being made on different devices) to sort in ways that user may not expect.

A typical example occurs when you make many edits to the same item on one device but not the other. If a particular item gets 15 edits on your phone and only two on your computer, then the phone edits will end up burying the computer edits. That's not so great if the latest computer edit is the one you really wanted to keep.

It's not so bad, though, as long as no data is lost in a merge, and as long as Delectus always gives you a way to see earlier edits. With those guarantees, you can always ask to see the edit history, and promote whichever edit you prefer to be the current one (really, of course, Delectus will insert a new op with the chosen data).

Whenever Delectus merges, it updates the revision count of the local list to be greater than the greatest revision it's seen so far, so new edits will always get revisions greater than anything in the op log. That tends to keep new edits new, even in the presence of concurrent edits.

== SQLite tables

So far, we've described Delectus data as if it's JSON expressions:

* `['listname', _metadata_, _nameText_]`
* `['comment', _metadata_, _commentText_]`
* `['columns', _metadata_, _columnsState_]`
* `['item', _metadata_, _itemState_]`

...where _metadata_, _columnsState_, and _itemState_ are JSON objects.

Indeed, this description is accurate if we're describing ops serialized to text, but a Delectus file isn't a text file. Delectus stores data in a SQLite file that uses several tables to turn the op log into a form that it can search, present, and update efficiently.

This section describes the tables Delectus uses for that purpose.

=== Op tables
=== The `delectus` table
=== Origin and identity maps
