= Delectus 2 Data
:toc:

== Concepts

=== Nodes

An installed copy of Delectus running on a specific device, in a process owned by a specific user, is called a *Delectus node*, or just a *node* for short. It's important for Delectus to be able to distinguish one node from another, because it uses the node's identity to distinguish between concurrent edits to the same data.

Delectus stores a 16-bit identifier called the *node identity* in a configuration file in the user's filesystem the firs time it runs. If this file is removed or corrupted, Delectus generates a new one.

If the node identity changes, the integrity of Delectus data files is not affected; Delectus simply thinks that new edits come from a new node.

=== Lists

Conceptually, Delectus manages documents called *lists*. A *list* is a named sequence of *items*. An *item* is a sequence of *fields* containing *values*.

A Delectus list is a table: each item is a row, and each field belongs to a named *column*. All items have the same columns with the same names and other attributes, but the values in the fields are unique to each item.

A Delectus list starts out empty. A user builds its contents piece-by-piece, by performing *edit* operations: adding items and columns, and updating fields and column attributes. Each edit changes the current state of the list.

There are four types of edits. Each one is represented by a named operation called an *op*. The four ops are:

. `*listname:*` Sets the name of the list.
. `*comment:*` Sets the list's comment text.
. `*columns:*` Sets the list's columns and their attributes.
. `*item:*` Adds or updates a single item.

At any given time, the state of a list is defined by the sequence of edits that has been performed on it. That sequence of edits is represented by a log of ops in *causal order*. Given that log, Delectus can always reproduce the state of the list at any point in its history. In fact, to Delectus, the op log _is_ the list.

*Causal order* means that a new op is always inserted after all existing ops, and that future edits and merges cannot cause an edit to appear before any op that existed in the log at the time it was inserted.

== Op syntax

Each op is an assertion of a change in the list's data. Before the op is inserted, the list contains one set of data; afterward, it contains another. The op declares the state that changes, including all new data.

Following is the abstract syntax of all four ops.

=== listname

The `listname` op sets the name of the list to a user-specified string.

===== Syntax: `listname  _revision_ _origin_ _timestamp_ _nameText_`

[cols="1,1,5",options="header"]
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus node that created it.
| `_nameText_` | `string` | The list's new name.
|===

=== comment

The `comment` op sets the list's comment text to a user-specified string.

=====  Syntax: `comment _revision_ _origin_ _timestamp_ _commentText_`

[cols="1,1,5",options="header"]
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus node that created it.
| `_commentText_` | `string` | The list's new comment text.
|===


=== columns

The `columns` op sets the current state of the list's columns. The parameters given as `{_label_: _attributes_}+` are one or more objects that specify the attributes of a labeled column. The label identifies the column; the `attributes` object defines that column's attributes.

===== Syntax: `columns _revision_ _origin_ _timestamp_ {_label_: _attributes_}+`

[cols="1,1,3",options="header"]
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus node that created it.
| `{_label_: _attributes_}+` | `object` | One object for each column. The key is the column's label; the value is an `attributes` object specifying the values of the column's attributes.
|===

===== The `attributes` object

In a `columns` op, the `attributes` object specifies the values of the column's attributes.

[cols="1,2,6",options="header"]
|===
| field | type | description
| `id` | `identity` | The column's unique identity. The column's label is derived from this value by serializing it to a string and prepending the letter 'L'.
| `name` | `string` | The name given to the column by the user.
| `order` | `real` | The recommended presentation order of the column.
| `sort` | `null`, `'ASC'`, `'DESC'` | Whether to sort the list on this column, and in which direction.
| `title` | `Boolean` | Whether this is the list's title column.
| `subtitle` | `Boolean` | Whether this is the list's subtitle column.
| `deleted` | `Boolean` | Whether this column has been marked deleted.
|===

=== item

The `item` op sets the current state of a specified item. If `(_origin_, _itemid_)` identify an existing item, then the op is an update to that item. Otherwise it's a new item.

The parameters given as `{_label_: _value_}+` are one or more objects that specify the values of the item's fields. The `_label_` identifies a column; the `_value_` gives the data for that column.

===== Syntax: `item _revision_ _origin_ _timestamp_ _itemid_ {_label_: _value_}+`

[cols="1,1,3",options="header"]
|===
| parameter | type | description
| `_revision_` | `integer` | The revision number of the op.
| `_origin_` | `origin` | Where the op was created.
| `_timestamp_` | `integer` | The time the op was created, according to the Delectus node that created it.
| `_itemid_` | `identity` | The identity if the item.
| `_deleted_` | `Boolean` | Whether the item is marked deleted.
| `{_label_: _value_}+` | `object` | One object for each column. The key is the column's label; the value is the value in that column. The value may be `null`, a `Boolean`, a `number`, or a `string`.
|===

=== Identities

Delectus must be able to uniquely identify each item in a list, and each edit that changes data. It's not sufficient to assign identifiers that are unique within a file, because Delectus supports editing different copies of a list and then merging the edits. If identifiers are only locally unique then they may collide with identifiers created in a different copy of the list. Identifiers must therefore be globally unique.

To satisfy these requirements, Delectus uses *identities*. An *identity* is a unique 16-byte value--a v4 UUID in binary form. Delectus uses them to identify a specific user's installation of Delectus on a given device (called the Delectus *node*), and to label user-created columns.

Identities appear in three different forms:

* *bytestring:* An identity value in raw, binary form. This is what we normally mean by the word "identity".
* *identity string:* An identity serialized to a hexadecimal text string. +
For example: `"5bdb46f7f21543cda83d17b5036e07f7"`
* *column label:* An identity string with the letter 'L' prepended. +
For example: `"L5bdb46f7f21543cda83d17b5036e07f7"` +
Called a "column label" because Delectus uses these strings to label user-created columns in SQLite files.

All three forms are equivalent. A given identity represents the same 16 bytes, and stands for the same Delectus object, regardless of whether it appears as a bytestring, and identity string, or a column label.

=== Origins

An *origin* is a 16-byte value computed by hashing a *node* identity with the pathname of a list file, using the SHAKE128 hash.

Each time Delectus opens a list file, it computes an origin for the file. Each time it writes an op into the file, it tags the op with the origin. If the file is moved or copied, the origin changes. If it's edited by a different user or on a different device, the origin changes.

It's not possible to reverse the hash and recover the node identity and the pathname, but Delectus doesn't need to. It only needs to guarantee that different nodes and different pathnames produce different origin values, so that it can distinguish edits that come from different places, and ensure that `(origin, identity)` and `(origin, revision)` pairs are globally unique.

=== Revisions

Each op is marked with a *revision*. A *revision* is an integer attached to the op at the time it's created. Each time Delectus inserts an op, it increments the list file's revision counter and inserts the new value with the op.

Each list file has its own revision counter. Because revision counters are updated independently and concurrently across devices and files, Delectus can't preserve the uniqueness of revisions across copies of a list, but even though revisions are not globally unique, the combination of an origin and a revision is. Each op can therefore be uniquely identified by the coordinates `(_origin_,_revision_)`.

Although it's inevitable that the revision numbers from a remote copy of a list will duplicate local ones, and although we can still distinguish edits with the same revision as long as they have different origins, it's still useful to minimize duplication. For one thing, once a list has merged edits from another copy, we would prefer not to insert more ops locally with duplicate revisions. It's better for ordering ops if all newly-added ops have new revision numbers.

Therefore, any time we merge ops from a different copy of a list, we determine the highest revision number we've seen in any op--local or global--and reset the revision count to one greater than that.

=== Itemids

Besides uniquely identifying ops, Delectus also needs to uniquely identify items. A user may update the same item many times, which means inserting many ops that all represent versions of the same item. Origin and revision are enough to identify an op, but not enough by themselves to distinguish one item from another. Origin and revision tell us which op we're talking about, but if it's an `item` op, how do we know whether it's adding a new item or updating an old one?

To solve that problem, we use an additional coordinate: `itemid`. The `itemid` is an integer that uniquely identifies a specific item with respect to a given origin. Like a revision, an itemid is not unique in itself, but the combination of the itemid with an origin is.

To recap, the unique identifying coordinates that Delectus uses are:

* For identifying an *op:* `(_origin_, _revision_)`
* For identifying an *item:* `(_origin_, _itemid_)`
* For identifying *a specific update of a specific item:* `(_origin_, _revision_, _itemid_)`

=== Timestamps

Each op carries a `timestamp`, which is an integer count of the number of milliseconds since midnight, January 1, 1900 GMT. The upper bound of a Delectus 2 timestamp is given by the range of integers that SQLite can represent. The largest integers SQLite can store are 64-bit signed, so timestamps have 63 bits of precision. That means the maximum timestamp is 9,223,372,036,854,775,807, which corresponds to  August 17th, 292,278,924 AD, at 12:55 PM.

Delectus assigns a timestamp to each op, but it doesn't use the timestamps to determine the current state of the list file's data. It accomplishes that using only the op and item coordinates discussed previously.

It uses timestamps to make the presentation of list data congenial for users. For example, Delectus determines which ops represent the current state of all the list's items using itemids, revisions, and origins, but once it has the correct `item` ops, the default view uses timestamps to present them in approximately the order that they were created.

== SQLite tables

A Delectus list file is a SQL database; Delectus stores ops and supporting data in a set of SQLite tables. This section describes those tables and how Delectus uses them.

=== Op tables

Each op type is stored in its own table.

==== The `listnames` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `name` | `TEXT` |
|===

==== The `comments` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `comment` | `TEXT` |
|===

==== The `columns` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `_[label]_+` | `_[attributes]_+` |
|===

==== The `items` table

[cols="1,1,4",options="header"]
|===
| column | type | description
| `revision` | `INTEGER` |
| `origin` | `INTEGER` |
| `timestamp` | `INTEGER` |
| `itemid` | `INTEGER` |
| `deleted` | `INTEGER` |
| `_[label]_+` | `_[value]_+` |
|===

=== The `latest_items` table

When Delectus opens a list file it executes a query that fetches the latest versions of all items in the `items` table. It stores the result in a temporary `latest_items` table. It then uses the `latest_items` table for all searches and other read operations on the list's items, enabling it to produce results more quickly than if it operated on the full `items` table.

When a user edits an item or column, Delectus inserts the resulting op into the persistent `items` table and then recomputes the `latest_items` table.

=== The `delectus` table
=== Origin and identity maps
==== The `identities` table
==== The `origins` table
