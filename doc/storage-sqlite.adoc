= Delectus 2 Storage

Delectus 2 stores *lists* in SQLite files, one list per file. This document explains how Delectus organizes and stores its data.

== Nodes

Put simply, a *node* is one specific, identifiable place that your list data comes from.

A Delectus *node* is an idetifier that stands for Delectus running on a specific *device* and *user account*. When you create or edit a Delectus list on your computer, the copy of Delectus running on your computer in your account is a node. When you edit the same list on your phone, it's still your list, but you're editing it with a different node.

If someone else logs into your computer on their own account, and they use Delectus, they're working with yet another a different node. Even though it's the same computer and probably the same copy of Delectus, it's a different user account, and that makes it a different node, according to Delectus.

The point of nodes is to enable Delectus to mark each edit with the user and device that it came from, so that it can correctly merge edits from different sources, especially in cases where the same user made two different edits to the same data on different devices.

When you first start Delectus, it generates and records a *node UD* on the device you run it on. If you wipe the device clean and reinstall Delectus, it will install a new node ID. Everything will still work correctly, and you can still use your old Delectus files; Delectus will just think that your new edits are coming from a new node.

A *node ID* is a UUID string in standard format. Delectus uses *time-first UUIDs* for all its IDs. Databases (like SQLite, which Delectus uses to store data) can index and sort time-first UUIDs efficiently, and they sort in order of the time they were created, which makes it easy for us to present list data in time order.

== Ops

=== Overview

There are four kinds of list data in a Delectus file:

. `*field:*` A container for a single simple value: a `null`, `boolean`, `number`, or `text`
. `*item:*` A row of fields
. `*column:*` A named column of fields in items
. `*list:*` A named collection of items and columns

Delectus stores one list in each file.

A Delectus file stores list data as an append-only log of *ops*. An *op* is a tuple of values in a specified format that represents both an instruction to update the state of a list, and a concrete representation of the list's new state. When you make a change to a list file, Delectus creates a corresponding op and checks its validity. If it checks out, Delectus adds it to the log of ops, which updates the state of the list.

The Delectus user interface constructs the user's view of the list by querying the log of ops for the latest version of each distinct data element.

=== Op format

There are four kinds of ops:

. `*listname:*` Assert the name of the list
. `*columns:*` Assert the list's columns
. `*item:*` Assert an item in the list
. `*sync:*` Assert that we successfully synced with another device's copy of the list. Delectus uses recorded `sync` ops to limit the data that it must exchange in order to bring two different copies of the same list into congruence.

All four op types share a common format, shown here:

[cols="1,2,4", options="header"]
.The *op* data format
|===
|field | type | description

|`*optype*` | `text` | The type of this op.
|`*opid*` | `opid` | The unique ID of this op.
|`*origin*` | `opid` | The device where this op originated.
|`*revision*` | `integer` | The revision number of this op.
|`*timestamp*` | `text` | An ISO-8601 time string recording the moment this op was created (according to its origin).
|`*item*` | `opid` | In `item`, the unique ID of this item.
|`*name*` | `text` | In `listname`, the new name of this list.
|`*deleted*` | `boolean` | In `item`, whether this item is deleted.
|`*peer*` | `opid` | In `sync`, the remote device with which we synced.
|`*columnid**` | `[columndata \| fielddata]*` | Zero or more `columndata` or `value` objects. In a `columns` op,  each `columnid` field contains a `columndata` object. In `item`, it contains a `fielddata` value.

|===

Not all ops use all  fields. In fact, the only fields used by all ops are `optype`, `opid`, `origin`, `revision`, and `timestamp`. All ops use the same data format, though, so that all can be asserted into the same SQLite table. That means that certain fields are unused in some ops.

Ops store `null` in unused fields.

The `*columnid**` field is different from the others. The other fields have the same labels and the same types in every op and in every list. Delectus uses them to maintain the consistency of data, to synchronize data between copies of a list, and to support user-interface features. We call these *metadata columns*. Users do not interact with them directly.

The `*columnid**` field, on the other hand, represents a variable number of *userdata columns*, each with a different label. These columns are created by users to store their data. There may be any number of them in a list.

The label of each userdata column is a string in `*columnid*` format. A `*columnid*` string starts as a type-first UUID string, but Delectus modifies it so that it can be used without escaping as a SQLite column label. It removes the hyphens from the UUID string, and adds an uppercase `C` to the start of the string.

==== `*columnid*`

A `*columnid*` string looks something like this:

    "C9167655e627a4794a756953591ea1e0e"

This is the type of string that Delectus uses for labels of userdata columns.

Users can create as many columns as they like. That means that there may be any number of `*columnid*` fields in an op, each one with its own `*columnid*` label. The sole restriction is that the number of `*columnid*` fields in the op must be equal to the number of userdata columns in the file after the op is appended to the log.

==== Motivation for `*columnid*` fields

Why not simply name userdata columns the same way we name metadata columns?

Because users may create any number of columns with any name you can imagine, and they may create them concurrently on two or more different devices. Delectus has to be able to ensure that it can merge op logs from any number of different devices in such a way that all the devices end up with the same consistent results. It has to be able to combine any number of columns, created independently of each other, and ensure that no data is ever lost because of naming collisions.

Delectus therefore automatically generates column labels for userdata columns, using UUIDs to ensure that no two userdata columns ever have the same label. Meanwhile, the user normally never sees the `columnid` label. Instead, users see a name that they give to the column, and which is stored along with other column metadata in a `columndata` object stored in the column itself, in a `columns` op.

Besides making it possible to support concurrent editing on different devices, managing userdata columns this way means that we don't have to impose any restrictions on the names users want to use for their columns--well, except for the restriction that each column within a list has a unique name. That restriction is for the sake of the user's sanity, though, not because of any technical limitation. Delectus could just as easily support multiple userdata columns with the same user-assigned name, but that would be a way for users to confuse themselves about their own data, so Delectus forbids it.

=== Format of data within ops

This section describes the details of the data stored in the fields of an op.

==== Op field types

The data types used in the fields of an op are defined as follows:

[cols="1,3", options="header"]
.*op* field types
|===
|type name | description

|`text`
|A text string

|`opid`
|A garden-variety UUID string. Delectus uses *time-first UUIDs*.

|`boolean`
|`true` or `false`

|`columndata`
|A JSON string representing a `columndata` object. See the "columndata" section below.

|`fielddata`
|A `null`, `boolean`, `number`, or `text` object.

|===

==== columndata

A `*columndata*` object is a JSON object that represents the attributes of a *userdata column*. The `columndata` object is defined as follows:

[cols="1,1,3", options="header"]
.The `*columdata*` object
|===
|attribute |type |description

|`id`
|`columnid`
|The column's unique ID. This is the `columnid` string used as the SQLite column's label.

|`name`
|`string`
|The user-defined name of the column; unique per list.

|`type`
|`boolean`, `number`, or `text`
|The expected type of data in the column. Used by Delectus to control sorting and presentation.

|`order`
|`double`
| User-defined order of appearance in the Delectus application; unique per list.

|`sort`
|`null` or one of the strings `asc` or `desc`
|`null` if Delectus should not sort the list on this column. `"ascending"` or `"asc"` if it should sort the list in ascending order by this column; `"descending"` or `"desc"` if it should sort in descending order. Exactly one column in each list has a non-null value on this attribute.

|`title`
|`boolean`
|If true, then this column is the *title column* of the list. That means it gets special presentation in some views of the list data. Delectus presents the title column more prominently. In compact views (for example on phones), the title column may be the only column the user sees in the default view. At most one column in a list is the title column. If there is no designated title column then Delectus chooses one arbitrarily.

|`subtitle`
|`boolean`
|If true, then this column is the *subtitle column* of the list. That means it gets special presentation in some views of the list data. Delectus uses the subtitle column to show supplemental information in some compact views. At most one column in a list is the subtitle column. If there is no designated subtitle column then Delectus does not present the subtitle view.

|`deleted`
|`boolean`
|Whether this column is marked deleted. Columns marked deleted are not shown in the Delectus UI unless users specifically request it.

|===


=== Defined  Delectus ops

Delectus defines four types of ops:

. `*listname*` asserts the name of the current list
. `*columns*` asserts the attributes of the list's columns
. `*item*` asserts the fields of a specific list item and whether it's currently marked deleted
. `*sync*` asserts that a *sync* operation has been completed successfully

This section describes each of these ops in greater detail.

==== listname
===== *listname* _opid_ _origin_ _name_ _revision_ _timestamp_

Asserts the name of the list. The current name of the list is the value of the `name` field in the latest `listname` op. The first op in any Delectus list is a `listname`.


[cols="1,1,3", options="header"]
|===
|field | value | comments

|`*optype*` | `"listname"` | this literal string
|`*opid*` | `_opid_` | this op's unique ID
|`*origin*` | `_opid_` | this device where this op originated
|`*revision*` | `integer` | this op's revision number
|`*timestamp*` | `text` | the time of this op's creation
|`item` | `null` | unused
|`*name*` | `_text_` | the list's new name
|`deleted` | `null` | unused
|`peer` | `null` | unused
|`columnid*` | `[null]*` | unused

|===


==== columns
===== *columns* _opid_ _origin_ _revision_  _timestamp_ [_columnid_]*

Asserts the list's current columns and their attributes. There may be any number of _columnid_ parameters, but their number and attributes must match the state of the Delectus file after the op is asserted.

Delectus checks the _columnid_ parameters before asserting the op into its log. If there are any inconsistencies that prevent Delectus from updating the file to reflect the _columnid_ parameters in the op, then Delectus signals an error and rejects the op without changing the file.

If there are columns specified in the op that do not exist in the local file then Delectus creates those columns before asserting the op into the log.

[cols="1,1,3", options="header"]
|===
|field | value | comments

|`*optype*` | `"columns"` | this literal string
|`*opid*` | `_opid_` | this op's unique ID
|`*origin*` | `_opid_` | this device where this op originated
|`*revision*` | `integer` | this op's revision number
|`*timestamp*` | `text` | the time of this op's creation
|`item` | `null` | unused
|`name` | `null` | unused
|`deleted` | `null` | unused
|`peer` | `null` | unused
|`*columnid**` | `[columndata]*` | column attributes for each column, as JSON strings (see `columndata`, above)

|===


==== item
===== *item* _opid_ _origin_ _revision_  _timestamp_ _item_ _deleted_ [_columnvalue_]*

Asserts an item into the list. If the _item_ ID is equal to any existing _item_ ID in the list, then this op becomes the new value of that item, superseding the previous one. If there is no existing item with this _item_ ID then this op represents a new item.


[cols="1,1,3", options="header"]
|===
|field | value | comments

|`*optype*` | `"item"` | this literal string
|`*opid*` | `_opid_` | this op's unique ID
|`*origin*` | `_opid_` | this device where this op originated
|`*revision*` | `integer` | this op's revision number
|`*timestamp*` | `text` | the time of this op's creation
|`*item*` | `opid` | The unique ID of this item
|`name` | `null` | unused
|`*deleted*` | `boolean` | Whether this item is marked deleted
|`peer` | `null` | unused
|`*columnid**` | `[fielddata]*` | item's field values, one for each column

|===

==== sync
===== *sync* _opid_ _origin_ _revision_  _timestamp_ _peer_

Asserts that Delectus has successfully completed a *sync* operation with a remote *peer*. The result of a successful sync is that the two copies of the list are now identical. Delectus reports sync failures as errors, but does not record them in the op log.

Delectus refers to recorded sync ops when performing future sync operations. Because two logs are the same up to the point of the most recent sync, the two peers need exchange only the ops recorded since that sync.


[cols="1,1,3", options="header"]
|===
|field | value | comments

|`*optype*` | `"sync"` | this literal string
|`*opid*` | `_opid_` | this op's unique ID
|`*origin*` | `_opid_` | this device where this op originated
|`*revision*` | `integer` | this op's revision number
|`*timestamp*` | `text` | the time of this op's creation
|`item` | `null` | unused
|`name` | `null` | unused
|`deleted` | `null` | unused
|`*peer*` | `opid` | the remote device with which we synced
|`columnid*` | `[null]*` | unused

|===


== SQLite tables

A Delectus data file is a SQLite 3 file that contains two tables:

. The `*delectus*` table stores the unique ID of the list, and the current version of the delectus file format.
. The `*list_data*` table stores the list's data as an append-only log of Delectus ops, as explained in the "Ops" section, above.


=== The `*delectus*` table

[cols="1,1,4", options="header"]
|===
|SQLite column | SQLite type affinity | description

|`"id"` |`TEXT` | The unique `opid` of this list.
|`"origin"` |`TEXT` | The unique `opid` of the node where this list was created.
|`"format"` |`TEXT` | The current version of the Delectus data format used in this file.

|===


=== The `*list_data*` table

[cols="1,1,4", options="header"]
|===
|SQLite column | SQLite type affinity | description

|`optype` | `TEXT` | The name of the op type.
|`opid` | `TEXT` | The unique `opid` of this op.
|`origin` | `TEXT` | The unique `opid` of the node that created this op
|`revision` | `INTEGER` | The integer revision number of this op. Unique per origin, but may be duplicated by ops from different origins.
|`timestamp` | `TEXT` | An ISO-8601 time string that records the time that the origin created the op (according the the origin's clock). This timestamp is not authoritative, and is used mainly for informative purposes, for the user's benefit.
|`item` | `TEXT` | The unique `opid` of this item. May be duplicated within a list by updates to the item.
|`name` | `TEXT` | The user-assigned name of this list. Used only in `listname` ops. The current name of the list is the value of this field in the latest `listname` op.
|`deleted` | `INTEGER` | A Boolean value that is true if this item is marked deleted, and false if not. Used only in `item` ops.
|`peer` | `TEXT` | The unique `opid` of a remote node with which this node has successfully completed a `sync` operation. Used only in `sync` ops.
|`_columnid*_` | `TEXT` | Zero or more SQLite columns representing userdata columns in this list. The label of each SQLite column is in `*columnid*` format.

In a `columns` op, the value in each field is of type `*columndata*`, and represents the attributes of the column in which it appears.

In an `item` op, the value in each field is of type `*fielddata*`, and represents the value of the field in the column of the item in which it appears.

|===
