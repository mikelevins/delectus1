# Delectus 2 Guide to test data

The file `make-test-data.lisp` contains some tools for constructing CSV files that contain Delectus log data suitable for importing into SQLite for testing. This file explains how to use those tools.

## 1. Generating test data

Follow these steps to generate data you can use to run SQL tests on the Delectus storage scheme:

1.  Use a unix-like system  
`make-test-data` uses the data in the system file /usr/share/dict/words to populate the test data.

2. Edit the output-file pathname  
`make-test-data` writes generated test data to the pathname in `$test-csv-file`, defined near the top of the file. Edit this parameter to define where you want the test data to be depoisted.

3. Load `make-test-data.lisp`  
Load `make-test-data.lisp` into your Lisp.

4. Run `make-test-data`  
Eval `(write-test-csv $test-csv-file)` in the Listener. It takes a few seconds to generate a csv file full of simulated Delectus op output.

5. Import the CSV data  
Follow these steps to import the generated CSV data into a SQLite 3 database:
    1. Create the database file:  
    `sqlite3 my-test-file.sqlite3`
    2. Create the test-data table:  
    Execute the SQL statement in Listing 1, below, to create the test table:  
    3. Activate csv mode for import:
    `sqlite> .mode csv`
    4. Import the data into the table created in Step 2:
    `sqlite> .import my-test-file.csv DelectusTest`

**Listing 1: Creating the data table**

```
create table DelectusTest ( 
    `type`, opid, origin, revision INT, 
    itemid, itemorder DOUBLE, deleted, name, 
    `ID57a71a3d_9704_456c_aeeb_50b17c4658c2` text, 
    `IDe37b7018_35d2_43c4_8159_e09c3ac9bb9c` text, 
    `ID8c2bf9bb_5baa_4848_9967_70800561ccea` text, 
    `ID483536ef_a62f_420a_9f1d_36410967169e` text 
);
```
## 2. Interacting with the test data

Adter you complete the steps in section 1, you will have a SQLite 3 database that contains Delectus 2 data generated by `make-test-data`. The database contains about 388 thousand rows that assert about 236 thousand words from /usr/share/dict, with about half of them slightly-altered duplicates and about eighty or ninety" columns" updates.

Following are examples of some SQL queries used to test the performance and correctness of the data.

### Sorting a user column numerically

The Delectus database format defines two types of columns: **metadata columns** and **userdata columns**.

**Metadata columns** are the same in every Delectus database. They are created and maintained by the Delectus application, and are used to support UI features, to merge versions of the list from different devices, and to maintain coherence and consistency of the data.

The metadata columns are: `type`, `opid`, `origin`, `revision`, `itemid`, `itemorder`, `deleted`, and `name`.

**Userdata columns** are created by users interacting with the Delectus application. A userdata column has type `TEXT` and a label autogenerated by Delectus. The autogenerated labels are constructed from UUIDs to ensure that a user cannot accidentally create two different columns with the same name on different devices. The column label that a user sees in the UI is an attribute of the JSON string stored in the latest "columns" op that creates or updates the columns.

Because userdata columns are type TEXT, they are normally sorted lexicographically. To sort a column numerically, the user must set the column's type to `'number'` (which creates a "columns" op that updates the column's JSON object so that its `'type'` attribute contains `'number'`). Delectus then sorts the column using the SQLite `CAST` operator to treat the columnvalues as numbers for sorting purposes.

The following SQL query illustrates how Delectus sorts a `TEXT` column in this way:

```
select `ID483536ef_a62f_420a_9f1d_36410967169e` as val 
from DelectusTest 
where type='item' 
order by cast(val as number);

```

### Getting an attribute of a column

List items are represented by `item` ops. The full set of columns in a list are represented by `columns` ops. A Delectus data file is treated as a time-ordered log of data updates. The current columns in the file are defined by the latest `columns` op. 

Attributes of userdata columns are stored in the columns themselves, in JSON objects. The latest value of each attribute for each column is defined by the JSON object in the latest `columns` op.

This query illustrates how to get the value of the `'label'` attribute of a userdata column:

```
select json_extract(`ID483536ef_a62f_420a_9f1d_36410967169e`,'$.label') 
from DelectusTest 
where type='columns' ;
```

### All items, sorted by time of creation

The following query shows how to fetch the latest values of all items in the database sorted in the order they were created.

Delectus represents a list as an append-only log of data assertions. TO find the current values for all items in the list, you must fetch all the items and sort them by revision number. Because the list may contain concurrent edits merged from different devices, it's possible for two or more `'item'` ops to contain different edits to the same version of the same item. To decide which one "wins"--that is, which is the accepted current value, Delectus sorts the items with the same itemid and revision number by the `origin` column. It arbitrarily chooses the one that sorts highest on that column as the latest, and therefore current, value.

In the UI, Delectus shows only the current value of each item in the list. All values for all items are retained, but only the latest ones are normally shown (the UI may provide tools for browsing older values).

This query shows how that kind of selection may be done. The technique uses `PARTITION BY` and `RANK` as explained in [this reference](https://www.sqlitetutorial.net/sqlite-window-functions/sqlite-rank/ ).

```
SELECT a.itemorder,a.`ID8c2bf9bb_5baa_4848_9967_70800561ccea` as word, a.revision, a.origin
  FROM (SELECT itemid, itemorder, revision, `ID8c2bf9bb_5baa_4848_9967_70800561ccea`, origin,
               ROW_NUMBER() OVER (PARTITION BY itemid ORDER BY revision, origin DESC) rank
          FROM DelectusTest WHERE type="item") a
 WHERE a.rank = 1 order by a.itemorder;
```

