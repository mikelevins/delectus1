= Compact Storage in SQLite Files

== Data types

[cols="1,1,4", options="header"]
.Types used in Delectus ops and tables
|===
|field type | datatype | description

|`<column_description>` | `TEXT` | A JSON object of the form +
`{ +
  id: <column_id>, +
  name: <string> +
  sort: 'ASC' or 'DESC' or false +
  type: <string> +
  title: <boolean> +
  subtitle: <boolean> +
  deleted: <boolean> +
  }`
|`<column_id>` | `TEXT` | A Delectus `identity` string
|`<identity>` | `TEXT` | A Delectus `identity` string
|`<ISO-8601-string>` | `TEXT` | An ISO-8601 time string
|`<item_number>` | `INTEGER` | An integer that is mapped to an `identity` in the `items` table
|`<origin_number>` | `INTEGER` | An integer that is mapped to an `identity` in the `origins` table
|`<revision_number>` | `INTEGER` | An integer incremented once for each locally-executed op
|`<string>` | `TEXT` | A text string

|===


== Ops

=== `listname`

----
{
  type: 'listname',
  origin: <origin_number>,
  revision: <revision_number>,
  timestamp: <ISO-8601-string>,
  name: <string>
}
----

=== `columns`

----
{
  type: 'columns',
  origin: <origin_number>,
  revision: <revision_number>,
  timestamp: <ISO-8601-string>,
  [<column_id>: <column_description>,]+
}
----

=== `item`

----
{
  type: 'item',
  origin: <origin_number>,
  revision: <revision_number>,
  timestamp: <ISO-8601-string>,
  item: <item_number>,
  deleted: <boolean>,
  [<column_id>: <field_value>,]+
}
----

=== `sync`

----
{
  type: 'sync',
  origin: <origin_number>,
  revision: <revision_number>,
  timestamp: <ISO-8601-string>,
  peer: <origin_number>
}
----

== Tables

=== `delectus`

The 'delectus' table stores metadata about the list contained in the file.

[cols="1,1,4", options="header"]
.The 'delectus' table
|===
|column | datatype | description

|`id` | `TEXT` | A Delectus `identity` string; the identity of this list
|`origin` | `TEXT` | A Delectus `identity` string; the Delectus node that created this list
|`format` | `TEXT` | The Delectus file-format version of this file
|`next_revision` | `INTEGER` | The next revision number that will be assigned
|`next_item` | `INTEGER` | The next item number that will be assigned

|===


=== `origins`

The 'origins' table contains a list of known Delectus nodes, and maps integer indexes, called *origin numbers* to their unique identity strings. The origin number of the local node is always zero.

[cols="1,1,4", options="header"]
.The 'origins' table
|===
|column | datatype | description

|`origin_number` | `INTEGER` | An integer used to identify an origin identity in this list file.
|`origin_identity` | `TEXT` | An `identity` string used to uniquely identify an origin in a list.

|===


=== `columns`

The 'columns' table contains a list of metadata describing the *userdata columns* in the 'data' table. The metadata includes such attributes as the user-assigned name of the column, whether the list is to be sorted on the column, and whether the column has been marked deleted.

[cols="1,1,4", options="header"]
.The 'columns' table
|===
|column | datatype | description

|`id` | `TEXT` | A Delectus `identity` string; the identity of this list

|===


=== `items`

The 'items' table maps *item numbers* to *identity strings*. An item number is an integer, unique per item identity and list file. (In other words, the same item identity may be identified by a different item number in a different list file.)

[cols="1,1,4", options="header"]
.The 'items' table
|===
|column | datatype | description

|`item_number` | `INTEGER` | An integer used to identify an item identity in this list file.
|`item_identity` | `TEXT` | An `identity` string used to uniquely identify an item in a list.

|===

=== `sync`

[cols="1,1,4", options="header"]
.The 'sync' table
|===
|column | datatype | description

|`id` | `TEXT` | A Delectus `identity` string; the identity of this list

|===

=== `data`

The 'data' table contains the list's data items--that is, the value of each userdata column for each item that the user has inserted in the list. If the user updates an existing item, a new row is inserted that reuses the old item number. If the user adds a new item, then a new item number is used as well.

To get a new item number, Delectus creates a new entry in the 'item' table, mapping the new iterm number to anew `identity` string.

[cols="1,1,4", options="header"]
.The 'data' table
|===
|column | datatype | description

|`id` | `TEXT` | A Delectus `identity` string; the identity of this list

|===
