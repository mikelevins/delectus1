= Delectus 2 Data Formats
mikel evins
:toc:

== Terminology

[cols="1,4",options="header"]
.Terminology used in this manual
|===
| term |  definition
| *column* | A named collection of *fields* with shared attributes from all *items* in a *list*, stored as a column in a SQLite table.
| *compacting* | The process of creating a new Delectus list by copying only the latest versions of live (undeleted) data from an existing list.
| *identity* |  A unique identification of some object, distinct from all others. Delectus uses identities for *nodes*, *lists*, *ops*, and other objects it works with. It represents an *identity* using the `identity` datatype.
| *field* | A container for a *value* occupying a single *column* of an *item*.
| *item* | An individual, user-created entry in a list, stored as a row in a SQLite table.
| *list* |  A Delectus document containing data organized in rows and columns, one *item* to each row, and one *field* to each column of the row. An item is a collection of fields; a list is a collection of items. Delectus stores each list in its own SQLite file, along with some associated *metadata*.
| *node* | A Delectus process running on a specific user account on a specific device. Delectus assigns a distinct *identity* to each node, and records the `identity` of the node that makes each change to a list file.
| *op* |  A structure in a list file that represents an update to the state of the list. Represented as a row in a SQLite table. Delectus list data is represented as a time-ordered append-only log of ops.
|===


== Delectus datatypes

=== Metadata and userdata

*Userdata* is the data that a Delectus user creates and stores in Delectus lists.

*Metadata* is data that Delectus automatically creates and maintains to help support application features.

As an example, when you add "milk" to your shopping list, the item "milk" is *userdata*. When you add or edit that item, Delectus automatically stores a timestamp that records when you edited it; that timestamp is *metadata*.

Delectus distinguishes between userdata and metadata, and stores them differently. It represents *userdata* using JSON values stored as `TEXT` in distinct *userdata columns*. It represents metadata using SQLite `NULL`, `NUMBER`, and `TEXT values` in *metadata columns*.

In a list file, userdata and metadata are both stored in the rows of the `listdata` table. Metadata is stored in a predefined set of *metadata columns*; userdata is stored in a variable set of user-defined *userdata columns*. For a full description of these columns, see the <<op-structure>> section, below.

=== Datatypes

==== Userdata

Userdata values are stored as `TEXT` strings representing JSON values. The following table defines the types of those values.

[cols="1,5",options="header"]
.Userdata types
|===
| type name |  description
| `Boolean` |  JSON `true`, `false`, or `null`. `null` is treated as `false` for logical purposes.
| `null` |  JSON `null`, representing an empty field.
| `number` | Any valid JSON `number`.
| `string` | Any valid JSON string.
|===

==== Metadata

Metadata fields contain SQLite `NULL`, `NUMBER`, or `TEXT` values.

Certain values have an interpretation beyond their SQLite type affinities. The following table defines those interpretations, as well as the roles of the standard SQLite `NULL`, `NUMBER`, and `TEXT` affinities.

[cols="1,5",options="header"]
.Metadata types
|===
| type name |  description
| `Boolean` |  A `NUMBER` value that can be `1`, `0`, or `NULL`. `1` represents true; the other values represent false.
| `column` | A `TEXT` string representing a JSON object that defines a userdata column's attributes. See the `<<column-definition>>` definition, below.
| `identity` | A globally unique string derived from a UUID, used in Delectus as a unique identifier.
| `NULL` | Signifies an empty metadata field.
| `NUMBER` | Signifies a number.
| `sort-order` | Any of the values `null`, `'ASC'`, or `'DESC'`. Specifies whether a column is the list's sort column, and if so, which direction to sort.
| `TEXT` | Signifies a text string.
| `timestamp` | A `TEXT` value interpreted as an ISO 8601 timestamp.
|===

=== `column` [[column-definition, column]]

A `column` is a JSON object that defines the name and other attributes of a *userdata column* in a list. Delectus stores `column` objects in the columns that they describe, in special `columns` opss

Following is the structure of a `column` object:

[JSON]
----
{
  id: <identity>,
  name: <string>,
  type: 'null' | 'Boolean' | 'number' | 'string',
  order: <number>,
  title: <Boolean>,
  subtitle: <Boolean>,
  sort: <sort-order>,
  deleted: <Boolean>
}
----

All fields of the `column` object except the `id` can be edited by the user. The `id` is immutable; it never changes after the column is created.

[cols="1,4",options="header"]
.Fields of the `column` object
|===
| field |  description
| `id` | The `identity` of the column. Also used as the label of the SQLite column that stores the column in the list file.
| `name` | The name of the column. It can be any text string, and can be changed by the user at any time.
| `type` | A string identifying the type of data that the user expects to put in the column.
| `order` | A decimal number used to tell Delectus in what order to present the columns in its UI. Delectus assigns 10.0 to the first column in a list, and increases the number by 10.0 for each column it creates afterward, but users may change these numbers at any time. Delectus forbids assigning the same `order` number to two or more columns.
| `title` | True if this column is to be used as the title of the item; false otherwise. Only one column may be the title column at a time. If no column is marked as the `title` column then Delectus chooses one arbitrarily to use as the title in views that require it.
| `subtitle` | True if this column is to be used as the subtitle of the item; false otherwise. Only one column may be the subtitle column at a time. If no column is marked as the `subtitle` column then Delectus presents items without a subtitle.
| `deleted` | True if the column has been marked deleted by the user; false otherwise.
|===


=== `opid` and `item` numbers

Delectus identifies each `op` and each `item` in a list file with an integer. Each list file maintains an `opid` counter and an `item` counter.

When Delectus inserts a new op, it increments the `opid` counter and stores the new number in the `opid` field of the new op. When it creates a new `item` op, it increments the `item` counter and stores the number in the `item` field of the op.

Delectus nodes on different devices or accounts may duplicate one another's `opid` and `item` numbers, but Delectus also assigns an `identity`, called `'origin'` to each op. The `opid` number and the `item` number are not globally unique, but the combination of an `opid` with an `origin`, or the combination of an `item` with an `origin`, is globally unique. Delectus is therefore able to uniquely distinguish each op by inspecting its `opid` and `origin`, and it can similarly distinguish each `item` by inspecting its `item` number and `origin`.

Delectus does not store the `opid` and `item` counters in the list file. Instead, when it assigns a new `opid`, it queries the `listdata` table for the current maximum `opid` and adds one to obtain the new `opid`. It gets a new `item` number in the same way, by inspecting the `item` field.

== Ops

An *op* is a structure that represents an update to the state of a Delectus list. A Delectus list is represented as an append-only time-ordered log of ops. After an op is added to the log, the state of the data and metadata in the list have changed in some way. Each type of op performs a different type of update.

An op is represented in a Delectus file as a row in the `listdata` table. Delectus only appends to the `listdata` table; it never deletes or overwrites existing data. Making any edit to a list therefore means adding a new op that supersedes any old ones.

This append-only discipline enables Delectus to safely merge data from concurrently-modified copies of a list without losing any data.

== Op structure [[op-structure]]

An *op* is a row in the `listdata` table that records an update to the state of the list. All information in Delectus lists is represented by ops.

There are four types of ops:

[cols="1,4",options="header"]
.Op types
|===
| optype |  Description
| `'sync'` | Records a successful sync of this list file with another.
| `'listname'` | Sets the name of the list.
| `'columns'` | Sets the attributes (that is, the `column` objects) of all columns.
| `'item'` | Adds or updates an item.
|===

These four ops together describe all data that a Delectus list can store, and all edits that may be made to it.

All ops have a common shared structure that is the same in every op, and in every list file. That structure defines a standard set of *metadata columns* used by every op in every list, and a set of *userdata* columns that is different from one list to another, and that can change over time as a user adds and changed columns.

The following table illustrates the two kinds of columns in Delectus ops:

[cols="1,1",options="header"]
.Op metadata and userdata columns
|===
| metadata columns |  userdata columns
| `'optype'`, `'opid'`, `'origin'`, `'timestamp'`, `'peer'`, `'file'`, `'name'`, `'item'`, `'deleted'` | `"Ic3be769f0a364bb682691493716b3e67"`, `"I43c2837007534861af6a4d87c375152d"`, `"I43c2837007534861af6a4d87c375152d"`, ... (for example)
|===

The metadata columns shown are exactly the ones that appear in every Delectus list. The userdata columns, on the other hand, are just examples; the real userdata columns will be different in every list.

The metadata columns are defined as follows:

[cols="1,2,4",options="header"]
.Common op structure
|===
| field | permitted values | description
| `optype` | `"sync"`,`"listname"`,`"columns"`,`"item"` | Identifies the type of op.
| `opid` | `_integer_` | Uniquely identifies the op.
| `origin` | `_identity_` | Uniquely identifies the node that created the op.
| `timestamp` | `_timestamp_` | The time that the op was created, as reported by the creating node.
| `peer` | `_identity_` | In a `'sync'` op, the `identity` of the Delectus node that we synced with.
| `file` | `_identity_` | In a `'sync'` op, the `identity` of the Delectus file that we synced with.
| `name` | `_string_` | In a `'listname'` op, the new name of the list.
| `item` | `_integer_` | In an `'item'` op, the `identity` of the item.
| `deleted` | `_Boolean_` | In an `'item'` op, whether the item is marked deleted.
|===

Userdata columns, on the other hand, are created and controlled by users. They vary in two ways:

. The userdata columns in one list are unique, completely different from the userdata column in any other list.
. The set of userdata columns in a single list may expand and change over time, as a user adds and edits columns.

Because users control userdata columns, we can't give a detailed definition of them, but we can illustrate their common structure:

[cols="1,4",options="header"]
.Userdata column structure
|===
| column label | column value
| `_[identity]_+` | A `'NULL'`, a `column` object, or a userdata value, depending on the op's `optype`.
|===

The notation `_[identity]_+` means that there may be one or more userdata columns, each with its own  `identity`.

Delectus assigns an `identity` to the column when it creates it. That `identity` is  used as the label of the SQLite column that represents the column, and is stored permanently in the `column` object that specifies the column's attributes.

For example, a newly-created column might get an `identity` like `"I0b70ea94f385437abd1a541cf76b698b"`. This new column will now and forever after have the `identity` `"I0b70ea94f385437abd1a541cf76b698b"`. The `identity` string will be the label of the SQLite column in the list file, and will be the value of the `id` field of the the `column` object that represents the column's attributes.

The value stored in the column depends on the `optype` of the op it appears in. The following table defines the values that may appear in userdata columns:

[cols="1,4",options="header"]
.Userdata column values
|===
| optype | permitted values
| `'sync'` | `NULL`
| `'listname'` | `NULL`
| `'columns'` | a JSON `column` object.
| `'item'` | a JSON `null`, `Boolean`, `number`, or `string` value.
|===


=== Why identities?

Why not just use user-assigned names as the column labels? For a couple of reasons:

First, if we used the user's names for column labels then SQLite's restrictions on column labels would restrict the names they can use. By using automatically-generated labels instead, we can store the user's choice of names in metadata, and enable users to give their columns any names they like.

Second, by using automatically-generated labels based on UUIDs we ensure that a user can create two columns on two different devices, and there will be no conflict when the copies of the list are merged. Both columns will be present in the merged copies of the list, and the user can delete one of them if it turns out to be redundant.

=== Userdata and metadata contents

The predefined columns labeled `'optype'`, `'opid'`, `'origin'`, `'timestamp'`, `'peer'`, `'file'`, `'name'`, `'item'`, and `'deleted'` store metadata.

The user-created columns whose labels are `identity` strings store userdata.

Like the columns themselves, the contents of the metadata columns are predefined and maintained automatically by Delectus.

The contents of userdata columns are not predefined. Users can add and change them at any time. Delectus creates new ones as-needed.

The contents of userdata columns depend on the type of op. In a `columns` op, the column contains a JSON `<<column-definition>>` object that defines the column's attributes. In an `item` op, the column contains userdata represented as a JSON value.

In `listname` and `sync` ops, the userdata fields are always empty.

Delectus creates a new list with the common shared metadata columns, and then normally then adds a default userdata column with a unique identity and the name `'Item'`. It then adds a single empty item to the list.

From that point on, the number, names, and contents of the userdata columns are up to the user.

== Tables

=== The `delectus` table

The `delectus` table stores data identifying the file, the list, and the Delectus node that created them. It also records the version of the file format used, and if the new list was created by *compacting* an existing *parent* list, then it records the `identity` of the parent.

[cols="1,2,4",options="header"]
.Structure of the `delectus` table
|===
| column | type | description
| `listid` | `_identity_`  | The unique identity of this list
| `fileid` | `_identity_`  | The unique identity of this list file
| `origin` | `_identity_`  | The unique identity of the Delectus node that created this list file
| `parent` | `_identity_` or `NULL`  | The unique identity of the Delectus list file from which this file was derived by a *compaction*
| `format` | `_TEXT_`  | The version of the Delectus file format in this list file
|===


=== The `listdata` table

The `listdata` table contains the log of ops, and therefore the data and metadata of the list.

[cols="1,2,4",options="header"]
.Structure of the `listdata` table
|===
| field | permitted values | description
| `optype` | `"sync"`,`"listname"`,`"columns"`,`"item"` | Identifies the type of op.
| `opid` | `_integer_` | Uniquely identifies the op.
| `origin` | `_identity_` | Uniquely identifies the node that created the op.
| `timestamp` | `_timestamp_` | The time that the op was created, as reported by the creating node.
| `peer` | `_identity_` | In `sync` ops, identifies the Delectus node we synced with.
| `file` | `_identity_` | In `sync` ops, identifies the Delectus list file we synced with.
| `name` | `_string_` | In `listname` ops, defines the name of the list.
| `item` | `_integer_` | In `item` ops, identifies the item.
| `deleted` | `_Boolean_` | In `item` ops, specifies whether the item has been marked deleted.
| `_[identity]_*` | `_column_` or `_value_`  | `NULL`, a `column` object or a JSON value, depending on the `optype` of the op.
|===

The `listdata` table stores all ops that have ever been added to the list. It stores metadata that enable Delectus to reliably sort the ops into a time-ordered sequence, and deterministically identify the latest and defining op that establishes the list name, the set of defined userdata columns and their attributes, and the laterst versions of all items in the list.

It also records each time Delectus successfully synchronized this copy of the list with another, in order to facilitate efficient synchronization between copies.

A newly-created Delectus list has exactly the columns shown above, with `_[identity]_*` replaced by a specific, newly-generated `identity` string. That `identity` labels a newly-created userdata column that Delectus automatically gives the name `'Item'`. Delectus adds a single item to the list, leaving the `'Item'` column empty, to be filled in by the user.

From that point, the number, names, and contents of the list's columns and items are controlled by the user.
